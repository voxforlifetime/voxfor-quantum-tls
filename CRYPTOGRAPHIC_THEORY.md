# Cryptographic Theory & Mathematical Foundations

## Table of Contents

1. [Quantum Physics & Computing Model](#quantum-physics--computing-model)
2. [Lattice Geometry & Hardness](#lattice-geometry--hardness)
3. [Module-LWE (VLK-1) In-Depth](#module-lwe-vlk-1-in-depth)
4. [Number Theoretic Transform (NTT) Analysis](#number-theoretic-transform-ntt-analysis)
5. [Hash-Based Signatures (VOX-SIG)](#hash-based-signatures-vox-sig)
6. [Decryption Failure Probability](#decryption-failure-probability)
7. [Side-Channel Resistance Theory](#side-channel-resistance-theory)

---

## Quantum Physics & Computing Model

To understand the threat, one must understand the physical principles that give quantum computers their power.

### 1. Superposition & The Qubit
A classical bit is in state $|0\rangle$ or $|1\rangle$. A quantum bit (qubit) is in a linear combination:
$$ |\psi\rangle = \alpha|0\rangle + \beta|1\rangle $$
where $\alpha, \beta \in \mathbb{C}$ and $|\alpha|^2 + |\beta|^2 = 1$.

A system of $n$ qubits exists in a superposition of $2^n$ basis states simultaneously:
$$ |\Psi\rangle = \sum_{x=0}^{2^n-1} c_x|x\rangle $$

Why this matters: A 256-qubit register holds $2^{256}$ complex amplitudes. Operating on this register applies a function $f(x)$ to all $2^{256}$ inputs simultaneously (Quantum Parallelism).

### 2. Entanglement & Interference
However, we cannot "read" all $2^{256}$ results. Measuring collapses the state to a single $|x\rangle$ with probability $|c_x|^2$.

Quantum algorithms work by constructive interference: manipulating amplitudes so that the "correct" answer has high probability (amplitude addition) and "wrong" answers cancel out (amplitude subtraction).

### 3. Shor's Algorithm (The RSA/ECC Killer)
Shor's algorithm uses the Quantum Fourier Transform (QFT) to find the period of a function $f(x) = a^x \pmod N$.
- Classical cost: Exponential in $\log N$.
- Quantum cost: Polynomial ($O((\log N)^3)$).
- Impact: Breaks RSA (integer factorization) and ECDH/ECDSA (discrete log).

### 4. Grover's Algorithm (The Search Engine)
Grover's algorithm searches an unsorted database of $N$ items in $O(\sqrt{N})$ steps.
- Classical: $O(N)$
- Impact: Halves the effective bit-strength of symmetric ciphers and hashes.
  - AES-128 → 64 bits (Broken)
  - AES-256 → 128 bits (Secure)
  - SHA-256 → 128 bits collision resistance (Secure)
  - VLK-1 Mitigation: We aim for >128 bits post-quantum, meaning >256 bits classical equivalent.

---

## Lattice Geometry & Hardness

Lattice cryptography is based on the geometry of high-dimensional grids.

### What is a Lattice?
A lattice $\mathcal{L}$ is a discrete subgroup of $\mathbb{R}^n$, generated by a basis matrix $\mathbf{B} = \{b_1, ..., b_k\}$:
$$ \mathcal{L}(\mathbf{B}) = \left\{ \sum_{i=1}^k z_i b_i : z_i \in \mathbb{Z} \right\} $$

Visually, imagine a grid of dots in 2D. You can describe this grid with "good" basis vectors (short, nearly orthogonal) or "bad" basis vectors (long, highly skewed).

### The Hard Problems
1.  Shortest Vector Problem (SVP): Find the non-zero vector $v \in \mathcal{L}$ with minimal Euclidean norm $||v||$.
2.  Closest Vector Problem (CVP): Given a target point $t \in \mathbb{R}^n$ (not in lattice), find the lattice point $v \in \mathcal{L}$ closest to $t$.

Why is this hard?
In high dimensions ($n > 500$), finding the shortest vector is exponentially hard. "Bad" bases are so skewed that standard rounding techniques (like Babai's algorithm) fail completely. Even quantum computers (Grover) only achieve a quadratic speedup, not exponential.

### LWE as a Lattice Problem
Learning With Errors (LWE) is an average-case relaxation of CVP (specifically BDD - Bounded Distance Decoding).
- Public Key: A "bad" description of a lattice (matrix $\mathbf{A}$).
- Encryption: A point near the lattice ($b = As + e$).
- Decryption: Solving CVP (finding $s$ given $b$) using the secret key (which is a "trapdoor" or related to the error distribution).

---

## Module-LWE (VLK-1) In-Depth

Standard LWE uses huge random matrices. Ring-LWE uses polynomial rings for efficiency but has algebraic structure. Module-LWE trades off between them for security and performance.

### Algebraic Structure
We work over the ring $R_q = \mathbb{Z}_q[X] / (X^N + 1)$.
- Elements are polynomials of degree $< N$ with coefficients in $\mathbb{Z}_q$.
- Multiplication is modulo $X^N+1$ (negacyclic convolution).

VLK-1 Parameters:
- $N=256$: Power of 2, enables efficient NTT.
- $q=3329$: Prime. Note $3329 = 13 \times 256 + 1$. This implies $q \equiv 1 \pmod{2N}$, guaranteeing existence of $2N$-th roots of unity.
- $k=3$: Module rank. The lattice dimension is $n = N \times k = 768$.

### The Math of Encryption
1.  KeyGen:
    - $\mathbf{A} \in R_q^{k \times k}$ (Public random matrix)
    - $\mathbf{s}, \mathbf{e} \in R_q^k$ (Secret small polynomials)
    - $\mathbf{t} = \mathbf{A}\mathbf{s} + \mathbf{e}$ (Public Key)

2.  Encryption:
    - $\mathbf{r} \in R_q^k$ (Ephemeral secret, small)
    - $\mathbf{u} = \mathbf{A}^T \mathbf{r} + \mathbf{e}_1$
    - $v = \mathbf{t}^T \mathbf{r} + e_2 + \text{Encode}(m)$
    - Ciphertext: $(\mathbf{u}, v)$

3.  Decryption:
    - Compute $v - \mathbf{s}^T \mathbf{u}$
    - Substitute definitions:
      $$ (\mathbf{s}^T \mathbf{A}^T \mathbf{r} + \mathbf{s}^T \mathbf{e}_1) - (\mathbf{A}\mathbf{s} + \mathbf{e})^T \mathbf{r} - e_2 - \text{Encode}(m) $$
    - The $\mathbf{A}$ terms cancel out!
    - Result: $\text{Encode}(m) + \text{Noise}$
    - Noise term: $\mathbf{s}^T \mathbf{e}_1 - \mathbf{e}^T \mathbf{r} + e_2$

If the Noise is smaller than $q/4$, we can round to recover $m$.

---

## Number Theoretic Transform (NTT) Analysis

The NTT is the "engine" of post-quantum crypto. It is a Fast Fourier Transform (FFT) over a finite field.

### Mathematical Definition
$$ \hat{a}_i = \sum_{j=0}^{N-1} a_j \zeta^{ij} \pmod q $$
where $\zeta$ is a primitive $N$-th root of unity.

### Negative Wrapped Convolution
We need $a(X) \cdot b(X) \pmod{X^N+1}$. Standard FFT computes modulo $X^N-1$.
Trick: We use $\psi = \sqrt{\zeta}$ (2N-th root).
Scale coefficients: $a'_i = a_i \psi^i$.
Then $\text{NTT}(a \cdot b)$ on the scaled vectors corresponds to multiplication in $R_q$.

### Constant-Time Implementation (Barrett Reduction)
The core danger in NTT is modular reduction.
Naive: `x % q` uses division (variable time).

Barrett Reduction:
Given $x$, we want $x \pmod q$.
Let $m = \lfloor 2^k / q \rfloor$.
Estimate quotient: $q_{est} = \lfloor (x \cdot m) / 2^k \rfloor$.
Remainder: $r = x - q_{est} \cdot q$.
Correction: If $r \ge q$, subtract $q$.

VLK-1 Implementation:
Uses a signed variant (Centered Reduction) to keep coefficients in $[-\frac{q-1}{2}, \frac{q-1}{2}]$. This minimizes noise growth during polynomial multiplication.

---

## Hash-Based Signatures (VOX-SIG)

### Winternitz vs. Lamport
VOX-SIG uses Lamport signatures.
- Lamport: Reveal 1 hash for bit 0, another for bit 1. Huge keys, fast.
- Winternitz (WOTS+): Trade time for size. Hash chain of length $w$. Reveal $w-x$ hashes to sign value $x$. Smaller keys, slower.

Why Lamport?
Simplicity and speed. VOX-SIG is research code; Lamport is easier to audit and prove secure (reduction to simple collision resistance) than WOTS+ (requires checksums, complex chaining).

### Preimage verification
We store the full Lamport public key (all pairs) to allow the verifier to check:
$$ H(\text{revealed\_key}) == \text{expected\_pk\_hash} $$
This prevents Key Substitution Attacks where an attacker finds a collision in the Merkle tree but doesn't know the Lamport preimage.

---

## Decryption Failure Probability

In LWE, decryption fails if the noise norm $||E|| > q/4$.
Noise $E = \mathbf{s}^T \mathbf{e}_1 - \mathbf{e}^T \mathbf{r} + e_2$.
This is a sum of products of small polynomials. The coefficients approach a Gaussian distribution (Central Limit Theorem).

Parameters:
- $q = 3329$
- $k = 3$
- $\eta = 2$ (CBD)

Variance Calculation:
- Variance of one coefficient in $\mathbf{s}, \mathbf{e}, \mathbf{r}$: $\sigma^2 = \eta/2 = 1$.
- Term $\mathbf{s}^T \mathbf{e}_1$: Sum of $k \times N$ products.
- Total Noise Variance $\sigma_{total}^2 \approx k \cdot N \cdot \sigma^4 ...$ (Simplified)

Using the tail bounds of the Bounded Gaussian distribution, the probability of any coefficient exceeding the threshold is roughly:
$$ P_{fail} \approx N \cdot \text{erfc}\left( \frac{q/4}{\sqrt{2}\sigma_{total}} \right) $$

For VLK-1 parameters, precise analysis (using Kyber scripts) gives:
$$ \delta < 2^{-174} $$
This means a decryption failure happens once every $10^{52}$ operations - effectively never.

---

## Side-Channel Resistance Theory

### The Timing Oracle
If `decapsulate(ct)` takes $T_1$ time for valid ciphertext and $T_2$ for invalid:
1. Attacker sends perturbed $ct'$.
2. If time is $T_1$, the perturbation didn't affect validity → helps deduce secret key bits.
3. If time is $T_2$, it did.

### Countermeasures in VLK-1
1.  Branchless Logic: `barrett_reduce`, `poly_add`, `poly_mul` execute same sequence of assembly instructions regardless of data.
    - Instead of `if (x > q) x -= q`, we use `x -= q & (mask)`.
2.  Implicit Rejection: Decapsulation *always* performs the full re-encryption check.
    - If check fails, we overwrite the shared secret with a pseudo-random value using constant-time `cmov` (conditional move).
    - $T_{valid} \approx T_{invalid}$.

### Cache Attacks
NTT accesses memory in a permuted order (bit-reversal).
- Danger: If access pattern depends on secret data.
- VLK-1: Access pattern depends only on $N$ (public constant). The secret coefficients are data, not indices.

---

Last Updated: December 2025
Author: Netanel Siboni (voxfor.com)
Research Period: Q4 2025 (3 Months Intensive R&D)
